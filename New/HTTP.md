
# HTTP

##  URL与资源

### Web资源

#### 媒体类型

HTTP给要通过Web传输的对象赋上MIME类型

 • HTML 格式的文本文档由 text/html 类型来标记。

 • 普通的 ASCII 文本文档由 text/plain 类型来标记。

 • JPEG 格式的图片为 image/jpeg 类型。

 • GIF 格式的图片为 image/gif 类型。

 • Apple 的 QuickTime 电影为 video/quicktime 类型。

 • 微软的 PowerPoint 演示文件为 application/vnd.ms-powerpoint 类型。

 MIME 类型有数百个

#### URI

 每个Web  服务器资源都有一个名字，这样客户端就可以说明它们感兴趣的资源是什么了。服务器资源名被称为统一资源标识符 （Uniform Resource Identifier ，URI ）。URI  就像因特网上的邮政地址一样，在世界范围内唯一标识并定位信息资源。这是Joe  的五金商店的Web  服务器上一个图片资源的URI ：

http://www.joes-hardware.com/specials/saw-blade.gif

显示了URI  是怎样指示HTTP  协议去访问Joe  商店服务器上的图片资源的。给定了URI ，HTTP  就可以解析出对象。URI  有两种形式，分别称为URL  和URN 。现在我们分别来看看这些资源标识符类型。

#### URL

 统一资源定位符（URL）是资源标识符最常见的形式。URL 描述了一台特定服务器上某资源的特定位置。它们可以明确说明如何从一个精确、固定的位置获取资源。

大部分URL  都遵循一种标准格式，这种格式包含三个部分。

• URL  的第一部分被称为方案 （scheme ），说明了访问资源所使用的协议类型。这部分通常就是HTTP  协议（http:// ）。

•  第二部分给出了服务器的因特网地址（比如，www.joes-hardware.com ）。

•  其余部分指定了 Web  服务器上的某个资源（比如，/specials/saw-blade.gif ）。现在，几乎所有的URI  都是URL 。

#### URN

 URI 的第二种形式就是统一资源名（ URN）。 URN 是作为特定内容的唯一名称使用的，与目前的资源所在地无关。使用这些与位置无关的 URN，就可以将资源四处搬移。通过 URN，还可以用同一个名字通过多种网络访问协议来访问资源。

#### URI URL URN的区别

![](/Users/innocence/Desktop/书籍/img/uri.png)





#### 方法

GET 从服务器向客户端发送命名资源

PUT 将来自客户端的数据存储到一个命名的服务器资源中去

DELETE 从服务器中删除命名资源

POST 将客户端数据发送到一个服务器网关应用程序

HEAD 仅发送命名资源响应中的HTTP 首部

#### Web页面中可以包含多个对象

 应用程序完成一项任务时通常会发布多个HTTP  事务。~~比如，Web  浏览器会发布一系列HTTP  事务来获取并显示一个包含了丰富图片的Web  页面。浏览器会执行一个事务来获取描述页面布局的HTML “框架”，然后发布另外的HTTP  事务来获取每个嵌入式图片、图像面板、Java  小程序等。这些嵌入式资源甚至可能位于不同的服务器上，因此，~~一个“Web  页面”通常并不是单个资源，而是一组资源的集合

### 协议版本

####  HTTP/0.9

HTTP 的1991 原型版本称为HTTP/0.9。这个协议有很多严重的设计缺陷，只应该用于与老客户端的交互。HTTP/0.9 **只支持GET 方法**，不支持多媒体内容的MIME 类型、各种HTTP 首部，或者版本号。HTTP/0.9 定义的初衷是为了获取简单的HTML 对象，它很快就被HTTP/1.0 取代了。

HTTP/0.9具有典型的无状态性，每个事务独立进行处理，事务结束时就释放这个连接。由此可见，HTTP协议的无状态特点在其第一个版本0.9中已经成型。一次HTTP/0.9的传输首先要建立一个由客户端到Web服务器的TCP连接，由客户端发起一个请求，然后由Web服务器返回页面内容，然后连接会关闭。如果请求的页面不存在，也不会返回任何错误码。

#### HTTP/1.0

1.0 是第一个得到广泛使用的HTTP 版本。HTTP/1.0 添加了版本号、各种HTTP首部、一些额外的方法，以及对多媒体对象的处理。

#### HTTP/1.0+ 

包括持久的keep-alive 连接、虚拟主机支持，以及代理连接支持都被加入到HTTP 之中，并成为非官方的事实标准。这种非正式的HTTP 扩展版本通常称为HTTP/1.0+。

- 请求与响应支持头域
- 响应对象以一个响应状态行开始
- 响应对象不只限于超文本
- 开始支持客户端通过POST方法向Web服务器提交数据，支持GET、HEAD、POST方法
- 支持长连接（但默认还是使用短连接），缓存机制，以及身份认证

#### HTTP/1.1

HTTP/1.1 重点关注的是校正HTTP 设计中的结构性缺陷，明确语义，引入重要的性能优化措施，并删除一些不好的特性。HTTP/1.1 还包含了对20 世纪90 年代末正在发展中的更复杂的Web 应用程序和部署方式的支持。HTTP/1.1 是当前使用的HTTP 版本。

1. 默认为长连接

   HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection：keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。

2. 提供了范围请求功能(宽带优化)

   HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。这是支持文件**断点续传**的基础。

3. 提供了虚拟主机的功能(HOST域)

   在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。

4. 多了一些缓存处理字段

   HTTP/1.1在1.0的基础上加入了一些cache的新特性，引入了实体标签，一般被称为e-tags，新增更为强大的Cache-Control头。

5. 错误通知的管理

   在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除

#### HTTP-NG（又名 HTTP/2.0）

HTTP-NG 是HTTP/1.1 后继结构的原型建议，它重点关注的是性能的大幅优化，以及更强大的服务逻辑远程执行框架。

1. 二进制分帧

   HTTP 2.0 的所有帧都采用二进制编码

   - 帧：客户端与服务器通过交换帧来通信，帧是基于这个新协议通信的最小单位。
   - 消息：是指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成。
   - 流：流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符（1、2 … N）；

2. 多路复用

   多路复用允许同时通过单一的HTTP/2.0 连接发起多重的请求-响应消息。有了新的分帧机制后，HTTP/2.0不再依赖多个TCP 连接去处理更多并发的请求。每个数据流都拆分成很多互不依赖的帧，而这些帧可以交错（乱序发送），还可以分优先级。最后再在另一端根据每个帧首部的流标识符把它们重新组合起来。HTTP 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接（每个域名一个连接）即可。

3. 头部压缩

   HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。HTTP/2.0 要求通讯双方各自缓存一份首部字段表，从而避免了重复传输。

4. 请求优先级

   浏览器可以在发现资源时立即分派请求，指定每个流的优先级，让服务器决定最优的响应次序。这样请求就不必排队了，既节省了时间，也最大限度地利用了每个连接。

5. 服务端推送

   服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度

### Web的结构组件

#### 代理

位于客户端和服务器之间的HTTP 中间实体。

首先我们来看看HTTP  代理服务器，这是Web  安全、应用集成以及性能优化的重要组成模块。

代理位于客户端和服务器之间，接收所有客户端的HTTP  请求，并将这些请求转发给服务器（可能会对请求进行修改之后转发）。对用户来说，这些应用程序就是一个代理，代表用户访问服务器。 出于安全考虑，通常会将代理作为转发所有Web  流量的可信任中间节点使用。**代理还可以对请求和响应进行过滤**。比如，在企业中对下载的应用程序进行病毒检测，或者对小学生屏蔽一些成人才能看的内容

#### 缓存

HTTP 的仓库，使常用页面的副本可以保存在离客户端更近的地方。

Web 缓存（ Web cache）或代理缓存（ proxy cache）是一种特殊的 HTTP 代理服务器，可以将经过代理传送的常用文档复制保存起来。下一个请求同一文档的客户端就可以享受缓存的私有副本所提供的服务了。

客户端从附近的缓存下载文档会比从远程Web  服务器下载快得多。HTTP  定义了很多功能，使得缓存更加高效，并规范了文档的新鲜度和缓存内容的隐私性。

#### 网关

连接其他应用程序的特殊Web 服务器。

网关（gateway）是一种特殊的服务器，作为其他服务器的中间实体使用。通常用于将HTTP 流量转换成其他的协议。网关接受请求时就好像自己是资源的源端服务器一样。客户端可能并不知道自己正在与一个网关进行通信。例如，一个HTTP/FTP 网关会通过HTTP 请求接收对FTP URI 的请求，但通过FTP协议来获取文档。得到的文档会被封装成一条HTTP 报文，发送给客户端。

#### 隧道

对HTTP 通信报文进行盲转发的特殊代理。

隧道（tunnel）是建立起来之后，就会在两条连接之间对原始数据进行盲转发的HTTP 应用程序。HTTP 隧道通常用来在一条或多条HTTP 连接上转发非HTTP 数据，转发时不会窥探数据。HTTP 隧道的一种常见用途是通过HTTP 连接承载加密的安全套接字层（SSL，Secure Sockets Layer）流量，这样SSL 流量就可以穿过只允许Web 流量通过的防火墙了。如图1-14 所示，HTTP/SSL 隧道收到一条HTTP 请求，要求建立一条到目的地址和端口的输出连接，然后在HTTP 信道上通过隧道传输加密的SSL 流量，这样就可以将其盲转发到目的服务器上去了。

#### Agent  代理

发起自动HTTP 请求的半智能Web 客户端。

用户Agent  代理（或者简称为Agent  代理）是代表用户发起HTTP 请求的客户端程序。所有发布Web 请求的应用程序都是HTTP Agent 代理。到目前为止，我们只提到过一种HTTP Agent 代理：Web 浏览器，但用户Agent 代理还有很多其他类型。比如，有些自己会在Web 上闲逛的自动用户Agent 代理，可以在无人监视的情况下发布HTTP 事务并获取内容。这些自动代理的名字通常都很生动，比如“网络蜘蛛”（spiders）或者“Web 机器人”（Web robots）。网络蜘蛛会在Web 上闲逛，搜集信息以构建有效的Web 内容档案，比如一个搜索引擎的数据库或者为比较购物机器人生成的产品目录。

## HTTP报文

### 方法

#### GET

GET 是最常用的方法。通常用于请求服务器发送某个资源。 HTTP/1.1 要求服务器实现此方法。图 3-7 显示了一个例子，在这个例子中，客户端用 GET 方法发起了一次HTTP 请求。

![](/Users/innocence/Desktop/书籍/img/GET.png)

#### HEAD

 HEAD 方法与 GET 方法的行为很类似，但服务器在响应中只返回首部。不会返回实体的主体部分。这就允许客户端在未获取实际资源的情况下，对资源的首部进行检查。使用 HEAD，可以：在不获取资源的情况下了解资源的情况（比如，判断其类型）；

• 通过查看响应中的状态码，看看某个对象是否存在；

• 通过查看首部，测试资源是否被修改了。

服务器开发者必须确保返回的首部与 GET 请求所返回的首部完全相同。遵循 HTTP/1.1 规范，就必须实现 HEAD 方法。

![](/Users/innocence/Desktop/书籍/img/head.png)

#### PUT

与GET  从服务器读取文档相反，PUT  方法**会向服务器写入文档**。有些发布系统允许用户创建Web  页面，并用PUT  直接将其安装到Web  服务器上去

PUT 方法的语义就是让服务器用请求的主体部分来创建一个由所请求的 URL 命名的新文档，或者，如果那个 URL 已经存在的话，就用这个主体来替代它。因为 PUT 允许用户对内容进行修改，所以很多 Web 服务器都要求在执行 PUT 之前，用密码登录。

![](/Users/innocence/Desktop/书籍/img/put.png)



#### POST

 POST 方法起初是用来向服务器输入数据的3。实际上，**通常会用它来支持 HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到它要去的地方**（比如，送到一个服务器网关程序中，然后由这个程序对其进行处理）。

![](/Users/innocence/Desktop/书籍/img/post.png)

#### TRACE

客户端发起一个请求时，这个请求可能要穿过防火墙、代理、网关或其他一些应用程序。每个中间节点都可能会修改原始的HTTP  请求。TRACE  方法允许客户端在最终将请求发送给服务器时，看看它变成了什么样子。RACE  请求会在目的服务器端发起一个“环回”诊断。行程最后一站的服务器会弹回一条TRACE  响应，并在响应主体中携带它收到的原始请求报文。这样客户端就可以查看在所有中间HTTP  应用程序组成的请求/  响应链上，原始报文是否，以及如何被毁坏或修改过。 TRACE 方法主要用于诊断；也就是说，用于验证请求是否如愿穿过了请求 / 响应链。它也是一种很好的工具，可以用来查看代理和其他应用程序对用户请求所产生效果。尽管 TRACE 可以很方便地用于诊断，但它确实也有缺点，它假定中间应用程序对各种不同类型请求（不同的方法—— GET、 HEAD、 POST 等）的处理是相同的。很多 HTTP 应用程序会根据方法的不同做出不同的事情——比如，代理可能会将POST 请求直接发送给服务器，而将 GET 请求发送给另一个 HTTP 应用程序（比如Web 缓存）。TRACE 并不提供区分这些方法的机制。通常，中间应用程序会自行决定对 TRACE 请求的处理方式。TRACE 请求中不能带有实体的主体部分。 TRACE 响应的实体主体部分包含了响应服务器收到的请求的精确副本。

#### OPTIONS

OPTIONS 方法请求 Web 服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法。（有些服务器可能只支持对一些特殊类型的对象使用特定的操作）。这为客户端应用程序提供了一种手段，使其不用实际访问那些资源就能判定访问各种资源的最优方式。图 3-12 显示了一个使用 OPTIONS 方法的请求。

![](/Users/innocence/Desktop/书籍/img/options.png)

#### DELETE

顾名思义，DELETE  方法所做的事情就是请服务器删除请求URL  所指定的资源。但是，客户端应用程序无法保证删除操作一定会被执行。因为HTTP  规范允许服务器在不通知客户端的情况下撤销请求。图3-13  显示了一个DELETE  方法实例。

![](/Users/innocence/Desktop/书籍/img/delete.png)





#### 可扩展的

HTTP 被设计成字段可扩展的，这样新的特性就不会使老的软件失效了。扩展方法指的就是没有在 HTTP/1.1 规范中定义的方法。服务器会为它所管理的资源实现一些 HTTP 服务，这些方法为开发者提供了一种扩展这些 HTTP 服务能力的手段。表 3-5 列出了一些常见的扩展方法实例。这些方法就是 WebDAV HTTP 扩展包含的所有方法，这些方法有助于通过 HTTP 将 Web 内容发布到 Web 服务器上去。

LOCK 允许用户“锁定”资源——比如，可以在编辑某个资源的时候将其锁定，以防别人同时对其进行修改

MKCOL 允许用户创建资源

COPY 便于在服务器上复制资源

MOVE 在服务器上移动资源

并不是所有的扩展方法都是在正式规范中定义的，认识到这一点很重要。如果你定义了一个扩展方法，很可能大部分 HTTP 应用程序都无法理解。同样，你的 HTTP应用程序也可能会遇到一些其他应用程序在用的，而它并不理解的扩展方法。在这些情况下，最好对扩展方法宽容一些。如果能够在不破坏端到端行为的情况下将带有未知方法的报文传递给下游服务器，代理应尝试传递这些报文。如果可能破坏端到端行为则应以 501 Not Implemented（无法实现）状态码进行响应。最好按惯例“对所发送的内容要求严一点，对所接收的内容宽容一些”来处理扩展方法（以及一般的 HTTP 扩展）。

### 100～199——信息性状态码

#### 100 Continue 

说明收到了请求的初始部分，请客户端继续。发送了这个状态码之后，服务器在收到请求之后必须进行响应。HTTP客户端应用程序有一个实体的主体部分要发送给服务器，但希望在发送之前查看一下服务器是否会接受这个实体。

~~**客户端与100 Continue**~~

~~如果客户端在向服务器发送一个实体，并且愿意在发送实体之前等待100 Continue响应，那么，客户端就要发送一个携带了值为100 Continue 的Expect 请求首部。如果客户端没有发送实体，就不应该发送100 Continue Expect 首部，因为这样会使服务器误以为客户端要发送一个实体。从很多方面来看，100 Continue 都是一种优化。客户端应用程序只有在**避免向服务器发送一个服务器无法处理或使用的大实体**时，才应该使用100 Continue。由于起初对100 Continue 状态存在一些困惑(而且以前有些实现在这里出过问题).因此发送了值为100 Continue 的Expect 首部的客户端不应该永远在那儿等待服务器发送100 Continue 响应。超时一定时间之后，客户端应该直接将实体发送出去。实际上，客户端程序的实现者也应该做好应对非预期100 Continue 响应的准备。有些出错的HTTP 应用程序会不合时宜地发送这个状态码。~~

~~**服务器与100 Continue**~~

~~**如果服务器收到了一条带有值为100 Continue 的Expect 首部的请求，它会用100Continue 响应或一条错误码来进行响应**。服务器永远也不应该向没有发送100 Continue 期望的客户端发送100 Continue 状态码。但如前所述，有些出错的服务器可能会这么做。如果出于某种原因，服务器在有机会发送100 Continue 响应之前就收到了部分（或全部）的实体，就说明客户端已经决定继续发送数据了，这样，服务器就不需要发送这个状态码了。但服务器读完请求之后，还是应该为请求发送一个最终状态码（它可以跳过100 Continue 状态）。最后，如果服务器收到了带有100 Continue 期望的请求，而且它决定在读取实体的主体部分之前（比如，因为出错而）结束请求，就不应该仅仅是发送一条响应并关闭连接，因为这样会妨碍客户端接收响应。~~

~~**代理与100 Continue**~~

~~如果代理从客户端收到了一条带有100 Continue 期望的请求，它需要做几件事情。如果代理知道下一跳服务器是HTTP/1.1 兼容的，或者并不知道下一跳服务器与哪个版本兼容，它都应该将Expect 首部放在请求中向下转发。如果它知道下一跳服务器只能与HTTP/1.1 之前的版本兼容，就应该以417Expectation Failed 错误进行响应。如果代理决定代表与HTTP/1.0 或之前版本兼容的客户端，在其请求中放入Expect首部和100 Continue 值，那么，（如果它从服务器收到了100 Continue 响应）它就不应该将100 Continue 响应转发给客户端，因为客户端可能不知道该拿它怎么办。代理维护一些有关下一跳服务器及其所支持的HTTP 版本的状态信息（至少要维护那些最近收到过请求的服务器的相关状态）是有好处的，这样它们就可以更好地处理收到的那些带有100 Continue 期望的请求了。~~





#### 101 Switching Protocols 

说明服务器正在根据客户端的指定，将协议切换成Update 首部所列的协议





### 200～299——成功状态码

| 状态码 | 原因短语                         | 含　　义                                                     |
| ------ | -------------------------------- | ------------------------------------------------------------ |
| 200    | OK                               | 请求没问题，实体的主体部分包含了所请求的资源                 |
| 201    | Created                          | 用于创建服务器对象的请求（比如，PUT）。响应的实体主体部分中应该包含各种引用了已创建的资源的URL，Location 首部包含的则是最具体的引用。服务器必须在发送这个状态码之前创建好对象。 |
| 202    | Accepted                         | 请求已被接受，但服务器还未对其执行任何动作。不能保证服务器会完成这个请求；这只是意味着接受请求时，它看起来是有效的。服务器应该在实体的主体部分包含对请求状态的描述，或许还应该有对请求完成时间的估计（或者包含一个指针，指向可以获取此信息的位置） |
| 203    | Non-Author i tat ive-Information | 实体首部包含的信息不是来自于源端服务器，而是来自资源的一份副本。如果中间节点上有一份资源副本，但无法或者没有对它所发送的与资源有关的元信息（首部）进行验证，就会出现这种情况。这种响应码并不是非用不可的；如果实体首部来自源端服务器，响应为200 状态的应用程序就可以将其作为一种可选项使用 |
| 204    | No Content                       | 响应报文中包含若干首部和一个状态行，但没有实体的主体部分。主要用于在浏览器不转为显示新文档的情况下，对其进行更新（比如刷新一个表单页面） |
| 205    | Reset Content                    | 另一个主要用于浏览器的代码。负责告知浏览器清除当前页面中的所有HTML 表单元素 |
| 206    | Partial Content                  | 成功执行了一个部分或Range（范围）请求。稍后我们会看到，客户端可以通过一些特殊的首部来获取部分或某个范围内的文档——这个状态码就说明范围请求成功了。206 响应中必须包含Content-Range、Date 以及ETag 或Content-Location 首部 |

### 300～399——重定向状态码

重定向状态码要么告知客户端使用替代位置来访问他们所感兴趣的资源，要么就提供一个替代的响应而不是资源的内容。如果资源已被移动，可发送一个重定向状态码和一个可选的Location  首部来告知客户端资源已被移走，以及现在可以在哪里找到它。这样，浏览器就可以在不打扰使用者的情况下，透明地转入新的位置了。

![](/Users/innocence/Desktop/书籍/img/300图1.png)



可以通过某些重定向状态码对资源的应用程序本地副本与源端服务器上的资源进行验证。比如，HTTP  应用程序可以查看其资源的本地副本是否仍然是最新的，或者在源端服务器上资源是否被修改过。图3-15  显示了一个这样的例子。客户端发送了一个特殊的If-Modified-Since  首部，说明只读取1997  年10  月之后修改过的文档。这个日期之后，此文档并未被修改过，因此，服务器回送了一个304  状态码，而不是文档的内容。

![](/Users/innocence/Desktop/书籍/img/304.png)



| 状态码 | 原因短语           | 含义                                                         |
| ------ | ------------------ | ------------------------------------------------------------ |
| 300    | Multiple Choices   | 客户端请求一个实际指向多个资源的URL 时会返回这个状态码，比如服务器上有某个HTML 文档的英语和法语版本。返回这个代码时会带有一个选项列表；这样用户就可以选择他希望使用的那一项了。有多个版本可用时，客户端需要沟通解决 |
| 301    | Moved Permanently  | 在请求的URL 已被移除时使用。响应的Location 首部中应该包含资源现在所处的URL |
| 302    | Found              | 与301 状态码类似；但是，客户端应该使用Location 首部给出的URL 来临时定位资源。将来的请求仍应使用老的URL |
| 303    | See Other          | 告知客户端应该用另一个URL 来获取资源。新的URL 位于响应报文的Location 首部。其主要目的是允许POST 请求的响应将客户端定向到某个资源上去 |
| 304    | 304 Not Modified   | 客户端可以通过所包含的请求首部，使其请求变成有条件的。如果客户端发起了一个条件GET请求，而最近资源未被修改的话，就可以用这个状态码来说明资源未被修改。带有这个状态码的响应不应该包含实体的主体部分 |
| 305    | Use Proxy          | 用来说明必须通过一个代理来访问资源；代理的位置由Location首部给出。很重要的一点是，客户端是相对某个特定资源来解析这条响应的，不能假定所有请求，甚至所有对持有所请求资源的服务器的请求都通过这个代理进行。如果客户端错误地让代理介入了某条请求，可能会引发破坏性的行为，而且会造成安全漏洞 |
| 306    | （未使用）         | 当前未使用                                                   |
| 307    | Temporary Redirect | 与301 状态码类似；但客户端应该使用Location 首部给出的URL     |







### 400～499——客户端错误状态码

有时客户端会发送一些服务器无法处理的东西，比如格式错误的请求报文，或者最常见的是，请求一个不存在的URL 。浏览网页时，我们都看到过臭名昭著的404 Not Found  错误码——这只是服务器在告诉我们，它对我们请求的资源一无所知。很多客户端错误都是由浏览器来处理的，甚至不会打扰到你。只有少量错误，比如404 ，还是会穿过浏览器来到用户面前。

| 状态码 | 原因短语           | 含义                                                         |
| ------ | ------------------ | ------------------------------------------------------------ |
| 400    | Bad Request        | 用于告知客户端它发送了一个错误的请求                         |
| 401    | Unauthorized       | 与适当的首部一同返回，在这些首部中请求客户端在获取对资源的访问权之前， 对自己进行认证。 |
| 402    | Payment Required   | 现在这个状态码还未使用，但已经被保留，以作未来之用           |
| 403    | Forbidden          | 用于说明请求被服务器拒绝了。如果服务器想说明为什么拒绝请求，可以包含实体的主体部分来对原因进行描述。但这个状态码通常是在服务器不想说明拒绝原因的时候使用的 |
| 404    | Not Found          | 用于说明服务器无法找到所请求的URL。通常会包含一个实体，以便客户端应用程序显示给用户看 |
| 405    | Method Not Allowed | 发起的请求中带有所请求的URL 不支持的方法时，使用此状态码。应该在响应中包含Allow 首部，以告知客户端对所请求的资源可以使用哪些方法。 |
| 406    | Not Acceptable     | 客户端可以指定参数来说明它们愿意接收什么类型的实体。服务器没有与客户端可接受的URL 相匹配的资源时，使用此代码。通常，服务器会包含一些首部，以便客户端弄清楚为什么请求无法满足。 |
| 407    | Not Acceptable     | 客户端可以指定参数来说明它们愿意接收什么类型的实体。服务器没有与客户端可接受的URL 相匹配的资源时，使用此代码。通常，服务器会包含一些首部，以便客户端弄清楚为什么请求无法满足。 |
| 408    |                    |                                                              |
| 409    |                    |                                                              |
| 410    |                    |                                                              |
| 411    |                    |                                                              |
| 412    |                    |                                                              |
| 413    |                    |                                                              |
| 414    |                    |                                                              |
| 415    |                    |                                                              |
| 416    |                    |                                                              |
| 417    |                    |                                                              |











### 500～599——服务器错误状态码







### HTTP首部

请求首部

响应首部

实体首部





## 连接

## Web服务器

## 代理

## 缓存

## 集成点：网关、隧道及中继

## 爬虫

## 客户端识别与cookie机制

## 基本认证机制

## 安全HTTP

## 实体和编码

## 重定向与负载均衡







