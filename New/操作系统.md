# 操作系统





## 进程和线程的区别

### 常见问题

1. 操作系统的四个特性。

并发：同一段时间内多个程序执行(注意区别并行和并发，前者是同一时刻的多个事件，后者是同一时间段内的多个事件)
共享：系统中的资源可以被内存中多个并发执行的进线程共同使用
虚拟：通过时分复用（如分时系统）以及空分复用（如虚拟内存）技术实现把一个物理实体虚拟为多个
异步：系统中的进程是以走走停停的方式执行的，且以一种不可预知的速度推进



1. 操作系统的主要功能。
2. 进程的有哪几种状态，状态转换图，及导致转换的事件。
3. 进程与线程的区别。
4. 进程通信的几种方式。
5. 进程同步的几种方式
6. 用户态和核心态的区别。
7. 死锁的概念，导致死锁的原因.
8. 导致死锁的四个必要条件。
9. 处理死锁的四个方式。
10. 预防死锁的方法、避免死锁的方法。
11. 进程调度算法。
12. 内存连续分配方式采用的几种算法及各自优劣。
13. 基本分页储存管理方式。
14. 基本分段储存管理方式。
15. 分段分页方式的比较各自优缺点。
16. 几种页面置换算法，会算所需换页数
17. 虚拟内存的定义及实现方式。

### 

作者：Ruheng

链接：https://www.jianshu.com/p/d254b138de03







互斥条件（Mutual exclusion）：资源不能被共享，只能由一个进程使用。



请求与保持条件（Hold and wait）：已经得到资源的进程可以再次申请新的资源。
非剥夺条件（No pre-emption）：已经分配的资源不能从相应的进程中被强制地剥夺。
循环等待条件（Circular wait）：



什么是死锁？

   如果一个进程集合里面的每个进程都在等待只能由这个集合中的其他一个进程（包括他自身）才能引发的事件，这种情况就是死锁。

这个定义可能有点拗口，下面用一个简单例子说明。
​     资源A、B，进程C、D描述如下：
　　资源A和资源B，都是不可剥夺资源，
　　现在进程C已经申请了资源A，进程D也申请了资源B，
　　进程C接下来的操作需要用到资源B，而进程D恰好也在申请资源A，
　　进程C、D都得不到接下来的资源，那么就引发了死锁。
然后套用回去定义：如果一个进程集合里面（进程C和进 程D）的每个进程（进程C和进程D）都在等待只能由这个集合中的其他一个进程（对于进程C，他在等进程D；对于进程D，他在等进程C）才能引发的事件（释放相应资源）。

这 里的资源包括了软的资源（代码块）和硬的资源（例如扫描仪）。资源一般可以分两种：可剥夺资源（Preemptable）和不可剥夺资源 （Nonpreemptable）。一般来说对于由可剥夺资源引起的死锁可以由系统的重新分配资源来解决，所以一般来说大家说的死锁都是由于不可剥夺资源 所引起的。

死锁的四个必要条件

互斥条件（Mutual exclusion）：资源不能被共享，只能由一个进程使用。
请求与保持条件（Hold and wait）：已经得到资源的进程可以再次申请新的资源。
非剥夺条件（No pre-emption）：已经分配的资源不能从相应的进程中被强制地剥夺。
循环等待条件（Circular wait）：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。







# WebGL





# 测试

## 单元测试







# 计算机体系结构

http://www.cnblogs.com/zengkefu/p/5589876.html









# C语言(未开始)

# C++(未开始)

# Linux(未开始)

# C++STL(未开始)

# Python(未开始)

# Pachi源码